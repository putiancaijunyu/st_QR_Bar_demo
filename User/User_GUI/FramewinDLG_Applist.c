/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
#include <stdio.h>
#include "DIALOG.h"
#include "FramewinDLG.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_FRAMEWIN_0  (GUI_ID_USER + 0x00)
#define ID_LISTWHEEL_0  (GUI_ID_USER + 0x03)
#define ID_BUTTON_DRCODE (GUI_ID_USER + 0x05)
#define ID_BUTTON_BARCODE (GUI_ID_USER + 0x07)
#if (GUI_USE_ARGB)
  #define COLOR_CONV GUICC_M8888I
#else
  #define COLOR_CONV GUICC_8888
#endif
#if (GUI_USE_ARGB)
#define LIGHTBLUE 0xFF2288EE
#else
#define LIGHTBLUE 0x00EE8822
#endif
typedef struct {
  WM_HWIN                      hWin;
  GUI_MEMDEV_Handle            hMemOverlay;
  GUI_MEMDEV_Handle            hMemRBorder;
  GUI_MEMDEV_Handle            hMemLBorder;
  const GUI_FONT GUI_UNI_PTR * pFont;
} WHEEL;
static char * _apMonth[] = {
  "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",
};
static WHEEL _aWheel[3];
// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, "Framewin_Applist", ID_FRAMEWIN_0, 0, 0, 480, 320, 0, 0x0, 0 },
  { LISTWHEEL_CreateIndirect, "Listwheel", ID_LISTWHEEL_0, 0, 0, 480, 40, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END
/*********************************************************************
*
*       _CreateDecoration
*/
static void _CreateDecoration(int xSize, int ySize, int LineHeight, WHEEL * pWheel) {
  GUI_MEMDEV_Handle hMemPrev;
  GUI_MEMDEV_Handle hMemRBorder;
  GUI_MEMDEV_Handle hMemLBorder;
  GUI_MEMDEV_Handle hMemOverlay;

#if (GUI_USE_ARGB)
  #define TRANS0 0x000000 | (0xFF000000 - 0x11000000)
  #define TRANS1 0x000000 | (0xFF000000 - 0xEE000000)
  #define TRANS2 0x000000 | (0xFF000000 - 0xFF000000)
                                 
  #define COLOR0 0x000000 | (0xFF000000 - 0x88000000)
  #define COLOR1 0x000000 | (0xFF000000 - 0x33000000)
  #define COLOR2 0xFFFFFF | (0xFF000000 - 0x88000000)
  #define COLOR3 0xAAAAAA | (0xFF000000 - 0x55000000)
  #define COLOR4 0x000000 | (0xFF000000 - 0xBB000000)
#else
  #define TRANS0 0x11000000
  #define TRANS1 0xEE000000
  #define TRANS2 0xFF000000
  
  #define COLOR0 0x88000000
  #define COLOR1 0x33000000
  #define COLOR2 0x88FFFFFF
  #define COLOR3 0x55AAAAAA
  #define COLOR4 0xBB000000
#endif

  //
  // Create left border
  //
  hMemLBorder = GUI_MEMDEV_CreateFixed(0, 0, 4, ySize, GUI_MEMDEV_NOTRANS, GUI_MEMDEV_APILIST_32, COLOR_CONV);
  hMemPrev    = GUI_MEMDEV_Select(hMemLBorder);
  GUI_SetColor(GUI_BLACK);
  GUI_DrawVLine(0, 0, ySize - 1);
  GUI_SetColor(0x00CCCCCC);
  GUI_FillRect(1, 0, 3, ySize - 1);
  //
  // Create right border
  //
  hMemRBorder = GUI_MEMDEV_CreateFixed(0, 0, 4, ySize, GUI_MEMDEV_NOTRANS, GUI_MEMDEV_APILIST_32, COLOR_CONV);
  GUI_MEMDEV_Select(hMemRBorder);
  GUI_SetColor(GUI_BLACK);
  GUI_DrawVLine(3, 0, ySize - 1);
  GUI_SetColor(GUI_LIGHTGRAY);
  GUI_FillRect(0, 0, 2, ySize - 1);
  //
  // Create overlay device
  //
  hMemOverlay = GUI_MEMDEV_CreateFixed(0, 0, xSize, ySize, GUI_MEMDEV_NOTRANS, GUI_MEMDEV_APILIST_32, COLOR_CONV);
  GUI_MEMDEV_Select(hMemOverlay);
  //
  // Gray gradients at top
  //
  GUI_DrawGradientV(0,                0,                   xSize - 1, (ySize * 2) / 10 - 1,               TRANS0, TRANS1);
  GUI_DrawGradientV(0, (ySize * 2) / 10,                   xSize - 1, (ySize / 2) - (LineHeight / 2) - 1, TRANS1, TRANS2);
  //
  // Gray gradients at bottom
  //
  GUI_DrawGradientV(0, (ySize / 2) + (LineHeight / 2),     xSize - 1, (ySize / 2) + (LineHeight / 2) + 2, COLOR0, TRANS2);
  GUI_DrawGradientV(0, (ySize / 2) + (LineHeight / 2) + 3, xSize - 1, ySize - (ySize * 2) / 10 - 1,       TRANS2, TRANS1);
  GUI_DrawGradientV(0, ySize - (ySize * 2) / 10,           xSize - 1, ySize - 1,                          TRANS1, TRANS0);
  GUI_DrawGradientV(0, ySize - 1,                          xSize - 1, ySize - 1,                          COLOR1, COLOR1);
  //
  // Translucent glass effect in the middle
  //
  GUI_SetColor(0x80000000);
  GUI_DrawHLine((ySize / 2) - (LineHeight / 2),     0, xSize - 1);
  GUI_SetColor(0x44000000);
  GUI_DrawHLine((ySize / 2) + (LineHeight / 2) - 1, 0, xSize - 1);
  GUI_DrawGradientV(1, (ySize / 2) - (LineHeight / 2) + 1, xSize - 2, (ySize / 2) - 1,                    COLOR2, COLOR3);
  GUI_DrawGradientV(1, (ySize / 2),                        xSize - 2, (ySize / 2) + (LineHeight / 2) - 2, COLOR4, COLOR4);
  GUI_MEMDEV_Select(hMemPrev);
  //
  // Store result
  //
  pWheel->hMemLBorder = hMemLBorder;
  pWheel->hMemRBorder = hMemRBorder;
  pWheel->hMemOverlay = hMemOverlay;
}
/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _OwnerDraw
*/
static int _OwnerDraw(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo) {
  WM_HWIN   hWin;
  WHEEL   * pWheel;
  int       xPos;
  int       yPos;
  int       xSizeWin;
  int       ySizeWin;
  int       xSizeDev;

  hWin = pDrawItemInfo->hWin;
  //
  // Process messages
  //
  switch (pDrawItemInfo->Cmd) {
  case WIDGET_ITEM_GET_XSIZE:
    //
    // Return x-size of item
    //
    return LISTWHEEL_OwnerDraw(pDrawItemInfo);
  case WIDGET_ITEM_GET_YSIZE:
    //
    // Return y-size of item
    //
    return LISTWHEEL_OwnerDraw(pDrawItemInfo);
  case WIDGET_ITEM_DRAW:
    //
    // Draw item
    //
    return LISTWHEEL_OwnerDraw(pDrawItemInfo);
  case WIDGET_DRAW_BACKGROUND:
    xSizeWin = WM_GetWindowSizeX(hWin);
    ySizeWin = WM_GetWindowSizeY(hWin);
    //
    // Draw background
    //
#if (GUI_USE_ARGB)
    GUI_SetColor(0xFFFFFFFF);
#else
    GUI_SetColor(0x00FFFFFF);
#endif
    GUI_FillRect(4, 0, xSizeWin - 5, ySizeWin - 1);
    break;
  case WIDGET_DRAW_OVERLAY:
    LISTWHEEL_GetUserData(hWin, &pWheel, sizeof(pWheel));
    xPos     = WM_GetWindowOrgX(hWin);
    yPos     = WM_GetWindowOrgY(hWin);
    xSizeWin = WM_GetWindowSizeX(hWin);
    xSizeDev = GUI_MEMDEV_GetXSize(pWheel->hMemRBorder);
    //
    // Draw border
    //
    GUI_MEMDEV_WriteAt(pWheel->hMemLBorder, xPos, yPos);
    GUI_MEMDEV_WriteAt(pWheel->hMemRBorder, xPos + xSizeWin - xSizeDev, yPos);
    //
    // Draw overlay
    //
    GUI_MEMDEV_WriteAt(pWheel->hMemOverlay, xPos, yPos);
    break;
  }
  return 0;
}

/*********************************************************************
*
*       _CreateListWheel
*/
static WM_HWIN _CreateListWheel(int x, int y, int xSize, int ySize, int Id, char ** apText, int NumItems, int TextAlign, WM_MESSAGE * pMsg, WHEEL * pWheel) {
  const GUI_FONT GUI_UNI_PTR * pFont;
  WM_HWIN                      hWin;
  int                          i;
  int                          LineHeight;

  //
  // Create LISTWHEEL object
  //
  //pFont         = &_FontBig;
  LineHeight    = 30;
  pWheel->pFont = pFont;
  hWin          = LISTWHEEL_CreateUser(x, y, xSize, ySize, pMsg->hWin, WM_CF_SHOW | WM_CF_HASTRANS, 0, Id, NULL, sizeof(void *));
 // LISTWHEEL_SetFont(hWin, &_FontBig);
  LISTWHEEL_SetTextAlign(hWin, TextAlign);
  LISTWHEEL_SetSnapPosition(hWin, (ySize - LineHeight) / 2);
  LISTWHEEL_SetOwnerDraw(hWin, _OwnerDraw);
  LISTWHEEL_SetUserData(hWin, &pWheel, sizeof(pWheel));
  LISTWHEEL_SetLineHeight(hWin, LineHeight);
  LISTWHEEL_SetTextColor(hWin, LISTWHEEL_CI_SEL, LIGHTBLUE);
  for (i = 0; i < NumItems; i++) {
    LISTWHEEL_AddString(hWin, *(apText + i));
  }
  if (TextAlign & GUI_TA_RIGHT) {
    LISTWHEEL_SetRBorder(hWin, 10);
  }
  //
  // Create overlay devices
  //
 // _CreateDecoration(xSize, ySize, LineHeight, pWheel);
  //
  // Fill WHEEL structure
  //
  pWheel->hWin = hWin;
  return hWin;
}
/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateFramewin
*/

void CreateFramewin_Applist(WM_MESSAGE * pMsg) {
	_CreateListWheel(  0, 0,  100, 140, GUI_ID_LISTWHEEL0, _apMonth,   GUI_COUNTOF(_apMonth),   GUI_TA_VCENTER | GUI_TA_HCENTER, pMsg, &_aWheel[0]);
	_CreateButton(pMsg->hWin, "DRCode", ID_BUTTON_DRCODE, (FRAME_WIDTH >> 1) - 100, 250, 100,  50, 0);
	_CreateButton(pMsg->hWin, "BarCode", ID_BUTTON_BARCODE, (FRAME_WIDTH >> 1) - 200, 250, 100,  50, 0);
}


void Button_QrCode_Handle_Msg(WM_MESSAGE * pMsg){
		WM_HWIN hItem;
		int     NCode;
		NCode = pMsg->Data.v;
		switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			case WM_NOTIFICATION_RELEASED:
					printf("Button_QrCode_Handle_Msg has pressd \n");
					_DeleteFrame();
					_CreateFrame(&_cbDialog_QRCode);
			break;
		}
		
	// USER START (Optionally insert additional code for further Ids)
	// USER END
}

void Button_BarCode_Handle_Msg(WM_MESSAGE * pMsg){
		WM_HWIN hItem;
		int     NCode;
		NCode = pMsg->Data.v;
		switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			case WM_NOTIFICATION_RELEASED:
				  printf("Button_BarCode_Handle_Msg has pressd \n");
					_DeleteFrame();
					FramewinDLG_BarCode_init();
					_CreateFrame(&_cbDialog_BarCode);
			break;
		}
		
	// USER START (Optionally insert additional code for further Ids)
	// USER END
}

void ListWheel_Handle_Msg(WM_MESSAGE * pMsg){
		WM_HWIN hItem;
		int     NCode;
		NCode = pMsg->Data.v;
		switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			case WM_NOTIFICATION_RELEASED:

			break;
			case WM_NOTIFICATION_SEL_CHANGED:
			// USER START (Optionally insert code for reacting on notification message)
			// USER END
			break;
			// USER START (Optionally insert additional code for further notification handling)
			// USER END
		}
		
	// USER START (Optionally insert additional code for further Ids)
	// USER END
}


/*********************************************************************
*
*       _cbDialog
*/
void _cbDialog_Applist(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  WM_HWIN hWin = pMsg->hWin;
	//_CreateListWheel(  0, 0,  100, 140, GUI_ID_LISTWHEEL0, _apMonth,   GUI_COUNTOF(_apMonth),   GUI_TA_VCENTER | GUI_TA_HCENTER, hWin, &_aWheel[0]);
  switch (pMsg->MsgId) {
		case WM_CREATE:
			WM_SetFocus(hWin);
			break;
		case WM_KEY:
      switch (((WM_KEY_INFO*)(pMsg->Data.p))->Key) { 
				case GUI_KEY_ESCAPE:
          GUI_EndDialog(hWin, 1);
          break;
				case GUI_KEY_TAB:
					WM_SetFocusOnNextChild(hWin);
					break;
       }
       break;		
		case WM_PAINT:
			 _PaintFrame();
		  CreateFramewin_Applist(pMsg);
			break;
		case WM_NOTIFY_PARENT:
			Id    = WM_GetId(pMsg->hWinSrc);
			NCode = pMsg->Data.v;
			switch(Id) {
					case ID_LISTWHEEL_0: // Notifications sent by 'Listwheel'
							ListWheel_Handle_Msg(pMsg);
					break;
					case ID_BUTTON_DRCODE: // Notifications sent by 'Listwheel'
							Button_QrCode_Handle_Msg(pMsg);
					break;
					case ID_BUTTON_BARCODE: // Notifications sent by 'Listwheel'
							Button_BarCode_Handle_Msg(pMsg);
					break;
			}
		// USER START (Optionally insert additional message handling)
		// USER END
		default:
				WM_DefaultProc(pMsg);
    break;
  }
}



// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
